---
layout : post
title: "C++：引用、指针和const限定符"
subtitle : "C++：引用、指针和const限定符"
date: 2017-03-22 13:41:00
author : "Lin"
header-img : "img/post-bg-2o15.jpg"
tags : -C++
---


# 1 引用（reference）
  `引用`为对象起了另一个名字。
  理解：-对某块内存地址起了一个新的变量名
        -有个人叫志明，后来起了个笔名叫“小明”
  通过将声明`&d`的形式来定义引用类型，其中d是声明的变量
  > int ival = 24;
  >int &refVal = ival; //refVal指向ival
  >int &refVal2 ;    //错误：引用并非对象，只是对已存在的对象起了一个新名字
  注意：
  1.对引用变量的修改相当与对原变量的修改（我打了小明一顿，其实就是打了志明）
  > refVal = 10; //此时ival==10
  2.所引用的类型都要和与之绑定的对象严格匹配。（按常理来讲，我们起名字一般有性别之分，起别名的时候一般也会跟性别类型相符合的，c++对这个相符合更加严格）
  > int &refVal3= 10; // 错误：引用类型的初始值必须是一个对象
  > double dval = 3.14;
  >int &refVal5= dval; //错误
  3.引用必须被初始化 （首先要志明这个人，才会有第二个称呼）

# 2 指针
  `指针`指向某一个对象。
  理解：-使用一块内存，存放另一块内存的地址，实现间接寻址
        -假设有一堆盒子按顺序排列编号，盒子A中放着盒子B的编号。可以通过A（指针）找到B
  定义：通过将声明写成`*d`的形式，其中d是变量名
  注意：-指针变量是一个对象，是有占内存的，并允许拷贝
  >int ****ip ,*ip2;
  >double dp ,*dp2;
  取地址：指针存放某个对象的地址，通过取地址`&`获取地址
  >int ival = 42;
  >int *p = &ival;
  指针值：
  指针的值（即地址）保证安全：
  1.指向一个对象
     此时允许使用解引用符（操作符*）
     >int ival =3;
     >int *p = &ival;
     >cout << *p;
  2.空指针
     可以用`nullptr`来初始化指针。代表指针不指向任何地方，也可以通过字面值`0`来初始化
  3.void * 指针
     该指针是一种 特殊的指针类型，可以用于存放任意的地址。
     一般用于：与别的指针比较、作为函数的输入或输出，或者赋给另一个void * 指针。
     不能直接操作 void * 指针所指的对象

# const限定符
  用途：有些值我们希望定义后在程序运行中不被改变。即可以用const对其加以限定
  >const int bufSize= 512;//此时bufSize被定义为一个常量，之后任何修改bufSize的行为都会引发错误
  注意：-const对象一但创建后其值就不能改变，所以const对象必须初始化
        -默认状态下，const对象仅在文件内有效，对于多文件使用，可以在const变量的声明和定义都添加`extern`关键字

##const的引用
  1.'常量引用'：引用绑定到const对象上
  >const int ci = 1024;
  >const int &r1 = c1;
  >r1 = 32;//错误：r1是一个常量引用，不允许对其赋值操作；
  >int &r2 = ci ;//错误；ci是个常量， 而r2是一个非常理引用，类型不匹配
  2.初始化和对const的引用
  引用的类型必须与其所引用的对象类型一致，但有两个例外
  * 初始化常理引用时允许用任意表达式作为初始值，只要表达式的结果能转换成引用类型即可
  >int i =42;
  >const int &r1 = i ;//允许将const int & 绑定到一个普通int对象上；
  >const int &r2 = 31 ; // 正确：31是一个字面值，可以转换成const int 类型
  >const int &r3 = r1*2; //正确
  >int &r4 = r1 * 2; //错误：r4不是一个常量引用
  * 对const的引用可能引用一个并非const的对象
  总结：对于const的引用的初始化可以概括为如下公式
  >const <变量类型> & <变量标识符>  =  <任意可转换为引用类型的表达式>
  而对于正常引用来说
  > <变量类型T1>  & <变量标识符> = <同变量类型T1的变量>
##指针和const
  1.`指向常量的指针`: 只能读取该指针所指向地址的值，却不能修改
  >const int a =1;
  >int *p = &a;//p是一个普通指针不能指向常量
  >const int *p1 = &a ; //正确
  总结公式：
  >const <变量类型> * <指向常量的指针> = <同变量类型的地址>
  2.`常量指针`：初始化时指向一个地址后，无法指向其他地址
  >int errNumb =0;
  >int *const p=&errNumb ; //将p指向errNumb的地址
##顶层const


  
